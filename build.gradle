plugins {
	id 'java' 
	id "org.sonarqube"
	id "org.beryx.jlink" version "2.21.2"
	id "org.javamodularity.moduleplugin" version "1.7.0"
}

sonarqube {
  properties {
    property "sonar.projectKey", "optyfr_Jtrrntzip"
    property "sonar.organization", "optyfr"
    property "sonar.host.url", "https://sonarcloud.io"
	property "sonar.sourceEncoding", "utf-8"
	property "sonar.log.level", "INFO"
	property "sonar.verbose", "true"
  }
}

apply plugin: 'java'
sourceCompatibility = 17
targetCompatibility = 17
apply plugin: 'eclipse'
apply plugin: 'org.javamodularity.moduleplugin'

def props = new Properties()
file("dist/ver.properties").withInputStream { props.load(it) }

version = props.getProperty("Specification-Version")+props.getProperty("Implementation-Version")

repositories {
	mavenCentral()
}

java {
	modularity.inferModulePath.set(true)
}

eclipse {
	classpath {
		downloadJavadoc = true
		downloadSources = true
		file {
			whenMerged {
				//Define a module as being either a library or a project dependency.
				//Test sources are excluded because eclipse wants them on the classpath for some reason (1)
				entries.findAll {  (it instanceof org.gradle.plugins.ide.eclipse.model.Library || it instanceof org.gradle.plugins.ide.eclipse.model.ProjectDependency) && !it.entryAttributes.get('gradle_used_by_scope').equals('test') }.each {
					it.entryAttributes['module'] = 'true'
				}
				
				//Test-scoped stuff should set the appropriate flag
				entries.findAll { (it.properties.kind.equals('src') || it.properties.kind.equals('lib')) && it.entryAttributes.get('gradle_used_by_scope').equals('test') }.each {
					it.entryAttributes['test'] = 'true'
				}
				
				entries.findAll { isConGradle(it) }.each {
				  it.entryAttributes['module'] = 'true'
				}
			}
		}
	}
}

boolean isConGradle(entry) {
	entry.kind == 'con' && entry.path == 'org.eclipse.buildship.core.gradleclasspathcontainer'
}


dependencies {
	implementation group: 'commons-codec', name: 'commons-codec', version: '1.+'
	implementation group: 'commons-io', name: 'commons-io', version: '2.+'
	implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.+'
}


sourceSets {
    main {
        java {
            srcDirs = ["src"]
        }
        resources {
            srcDirs = ["src"]
        }
    }
}

jar {
	manifest {
		attributes(
			"Manifest-Version"     : "1.0",
		    "Specification-Title"  : "Jtrrntzip",
		    "Specification-Version": props.getProperty("Specification-Version"),
        	"Implementation-Title" : "JTrrntzip",
            "Implementation-Version" : props.getProperty("Implementation-Version"),
            "Main-Class"           : "JTrrntzip.Program",
            "Class-Path"           : configurations.compileClasspath.collect { 'lib/' + it.getName() }.join(' ')
		)
		archiveFileName = project.archivesBaseName + '.jar'
	}
}

task distZip2(type: Zip, dependsOn: jar) {
	from (configurations.compileClasspath) {
		into('lib')
	}
	from (jar)
	from ('dist') {
		include '*.bat'
		include '*.sh'
		fileMode = 0755
	}
	archiveFileName = project.archivesBaseName + '-' + project.version + '.zip'
	destinationDirectory = file("$buildDir/distributions/")
}

assemble.dependsOn distZip2
